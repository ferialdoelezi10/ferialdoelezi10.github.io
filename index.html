<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smartville Documentation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            font-size: 3em;
            color: #0056b3;
            text-align: center;
            margin-top: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        h2,
        h3,
        h4 {
            color: #0056b3;
        }

        p {
            line-height: 1.6;
        }

        pre {
            background-color: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }

        a {
            color: #0056b3;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
            background: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .content {
            padding: 20px 0;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        code {
            background: #eee;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 80%;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>Smartville</h1>
            <p>This is the official SmartVille repository</p>
            <p>Smartville is an open-source testbed based on GNS3, Pytorch, and Docker for training and testing online
                intrusion detection systems based on machine learning.</p>
            <p>Feel free to contribute!</p>
            <p>The related paper <em>"SmartVille: an open-source SDN online-intrusion detection testbed"</em> is under
                review. Stay tuned!</p>
        </div>

        <div class="content">
            <img src="https://github.com/DISTA-IoT/smartville/blob/release_1.0/readme_imgs/smartville.png?raw=true"
                alt="Smartville Architecture Diagram">

            <h2>Installation</h2>
            <h3>Setting Up the Program on a Native Linux Distribution or WSL</h3>
            <p>This guide provides step-by-step instructions for setting up the testbed on a native Linux distribution.
                We have not verified if it works on the Windows Subsystem for Linux (WSL).</p>

            <h4>GNS3</h4>
            <p>Install the GNS3 software following the official documentation at: <a
                    href="https://docs.gns3.com/docs/getting-started/installation/linux/">https://docs.gns3.com/docs/getting-started/installation/linux/</a>
            </p>
            <p>Start the server either via GUI or by running:</p>
            <pre>gns3server</pre>
            <p>The server will run on <em>localhost:3080</em> as default.</p>

            <h4>Dependencies</h4>
            <p>All the required dependencies are listed in the <code>requirements.txt</code> file.</p>
            <pre>pip install -r requirements.txt</pre>

            <h4>Docker Images</h4>
            <p>The docker images used to build the nodes can be obtained by running the Makefile:</p>
            <pre>make all</pre>

            <h4>Setup</h4>
            <p>Modify the line 21 in file <code>controller.dockerfile</code> and insert your wandb API key as:</p>
            <pre>your_wandb_api_key.txt</pre>

            <h2>Usage</h2>
            <h3>Build Topology</h3>
            <p>To start the <em>star topology</em> execute <code>star_topology.py</code>:</p>
            <pre>python3 utils/star_topology.py</pre>
            <p>You will get in the GNS3 GUI a new project with this scenario.</p>

            <img src="https://github.com/DISTA-IoT/smartville/blob/release_1.0/readme_imgs/topology.png?raw=true"
                alt="GNS3 Topology Diagram" class="center">
            <p>Each node can communicate with eachother and everyone has Internet connection available.</p>
            &nbsp
            
            <h4>Container Manager </h4>
            <p>Execute the container_manager script and it will guide you through the rest!</p>
            <pre>python3 utils/container_manager.py</pre>
            <p>Stay tuned for a full walk-through tutorial!</p>
            
            <h4>Modify nodes </h4>
            <p>Each node can be modified or replaced by manipulating the node.dockerfile and star_topology.py to fit the desired requirements.</p>
            
            <h>Troubleshooting</h2>
            <h4>gns3_server.conf is not found </h4>
            <p>The file "gns3_server.conf" which contains GNS3's setup configuration should be generated automatically during GNS3 installation.However it's a known issue that this may not happen. The script generate_default_conf.sh can be run in terminal via:</p>
            <pre>sh generate_default_conf.sh</pre>
            <p>It creates the default configration file in the default directory for linux $HOME/.config/GNS3/2.2/.</p>

        
        <p>Networking environments are composed of a data plane, responsible for forwarding packets, and a control plane, responsible for determining how packets are forwarded. To illustrate the difference between SDN and traditional networking, consider the following example. If Alice wants to email Bob, Alice’s router will forward the packets (data plane) according to its routing table (control plane) to Bob’s router. In traditional networking, the data and control planes reside on the same device, whereas in SDN, a separate "layer" known as the controller is added between the data plane and the control plane. The controller acts as centralized intelligence that specifies how the nodes must handle the packets.

            There are four types of interactions in SDN. The controller interacts with the application plane through the so-called Northbound APIs. Through these APIs, applications communicate network resource requisites (data, storage, bandwidth, etc.) so the network can be configured accordingly. Northbound APIs should adhere to the REST criteria.
            
            On the other hand, the controller interacts with the network forwarding elements (data plane) through the Southbound APIs, which allow the controller to send commands directly to the nodes. Protocols such as OpenFlow and NETCONF were created for this purpose. Third, interactions between SDN and traditional networks are made possible via the Westbound APIs that use hybrid solutions such as SDN-IP, RouteFlow, and BTSDN. Lastly, interactions from SDN to SDN are made possible via the Eastbound APIs that use protocols such as HyperFlow and Onix.
            
            Docker Containers
            A Docker container characterizes each node in the SmartVille testbed. The container images are buildable using the corresponding Dockerfiles that handle all the dependencies and the nodes' internal file-system structure.
            
            This example of code represents the Dockerfile of each victim node. It's possible to identify four main Docker containers in our testbed:
            
            Controller: All the dependencies to run the controller and a suite of networking tools are installed. The POX library and PyTorch are retrieved and set to the gar-experimental branch. Kafka, Grafana, and Prometheus tools are retrieved and ports 9090, 9092, and 3000 are exposed to allow the instance of the three servers. Lastly, the script entrypoint.sh, which keeps the application alive, is run.
            Victim: All the dependencies to run the victim behavior are installed (Python3, TCP Replay, Scapy, Kafka, network tools) and the victim's scripts are imported into the file system.
            Attacker: All the dependencies to run the attacker behavior are installed (Python3, TCP Replay, Scapy, Kafka, network tools) and the scripts of the different cyberattacks are copied into the file system.
            Switch: The container of the OpenVSwitch is based on the official GNS3 OpenVSwitch appliance. However, the boot kernel has been modified to suit our application scenario via the boot.sh script.
            The Docker containers can be modified to match the configuration of every desired device that needs to be emulated in the network topology.
            
            OpenFlow Switch
            The OpenVSwitch is based on the GNS3 appliance, but the boot kernel is modified at launch by the boot.sh script:
            
            The last part of the script sets the switch to listen for a controller on physical port br0 with IP address 192.168.1.1 port 6633. This part can be modified to fit the desired IP range case scenario.
            
            OpenFlow switches operate based on a set of high-level commands defined by the OpenFlow protocol, providing a flexible and programmable approach to network management. When an OpenFlow controller issues OpenFlow commands, such as flow table modifications or routing instructions, the switch processes these directives to define its forwarding behavior. The switch maintains a flow table that stores rules specifying how to handle incoming packets. Each rule is characterized by a set of fields that identify the sender, the receiver, the used communication protocol, and a set of actions to perform when the switch receives a packet that matches those fields. Each time a packet is received by the switch, it consults its flow table to determine the appropriate action to perform, such as forwarding, dropping, or modifying the packet.
            
            If none of the rules match the packet's parameters, a flow miss occurs. The packet is sent to the controller, which has to build and send back an appropriate OpenFlow command to the switch. This ensures that the next time a similar packet arrives, it will trigger a flow hit and be handled directly by the switch. This paradigm allows for dynamic network behavior adjustments, as the controller can remotely instruct switches to adapt to changing network conditions. OpenFlow's separation of the control and data planes empowers administrators to centrally manage and orchestrate network policies, enabling agility and responsiveness in modern network infrastructures.
            
            IoT Traffic Details
            The Aposemat IoT-23 dataset was used in our work to reproduce realistic IoT attack and honeypot patterns. The following attacks were extracted from the original PCAP files that are publicly available. Unless explicitly stated otherwise, we extracted these flows using the attacker origin IP address as the filtering criterion. Recall that source and destination IP addresses and transport-layer ports were online masked before feeding the neural modules with raw packet bytes.
            
            Hajime: This Trojan malware searches to exploit Linux-related vulnerabilities. It was extracted from the dataset's capture 9.1. We extracted 5e4 flows.
            Hakai: This is a distributed denial-of-service (DDoS) botnet, a specialization of the Mirai and Gafgyt malware. Extracted from dataset's capture 8.1. 1.2e4 flows were extracted.
            Bashlite: This is another more general DDoS botnet. Dataset's capture 60.1. 5e4 flows extracted.
            Mirai: This is an open-source DDoS attack especially used over IoT devices. Capture: 34.1. Flows: 2.4e4.
            Torii: A Command and Control (C&C) and Information Gathering malware. Capture: 20.1. Flows extracted: 5e4.
            Muhstik: A worm based on the Mirai Botnet. Among others, it targets IoT devices. Commonly used to mine cryptocurrency and perform DDoS attacks. Capture: 3.1. Flows extracted: 5e4.
            Okiru: Another C&C Botnet that targets ARC processors, commonly used in wearables, and medical IoT, among others. Capture 7.1. Flows extracted: 5e4. The criteria for extracting these attack flows included target source and destination transport ports.
            Horizontal Scan: 5e4 traffic flows related to generic Horizontal Scan (HScan) were extracted from dataset's capture 1.1.
            C&C HeartBeat: Generic heartbeat-related server-side flows were also extracted in the context of the C&C traffic. Capture 7.1. Flows extracted: 0.15e4.
            Generic DDoS: Also, a set of 5e4 generic DDoS-related flows were extracted in the context of the C&C traffic from capture 7.1.
            The honeypot devices used by the authors of the IoT-23 captures were used in our cyber-ranch to emulate honeypot IoT devices used as attack victims. More specifically, these honeypots were the following:
            
            Somfy Door Lock Device: All the flows contained in the first three captures of folder Honeypot7.1 were extracted. These flows are related to a smart door lock device. In our topology, two nodes reproduced these flows.
            Philips HUE Smart LED Lamp: These flows were extracted from the folder Honeypot4.1. One node reproduced these flows in our topology.
            Amazon Echo Home Intelligent Personal Assistant: These flows were extracted from the folder Honeypot5.1. One node reproduced these flows in our topology.
            The interested reader is referred to for more details on these captures. All the flow extraction code is open-sourced alongside the testbed.
            
            Grafana, Kafka, Prometheus
            Apache Kafka is a distributed data streaming platform commonly referred to as a messaging system. It is capable of publishing messages, storing, and processing records in real-time. Kafka handles immense volumes of data where multiple clients can consume or publish messages on its topics. In our testbed, it's used by the nodes that act as producers to send information related to their CPU, RAM, and network-related metrics while creating a new topic for each of them. The controller will then connect as a consumer to the Kafka server to consume this data.
            
            Prometheus is a system for monitoring systems and services. It collects metrics from configured targets at defined intervals, evaluates rule expressions, displays the results, and can trigger alerts when specified conditions are observed. In our work, Prometheus is used to guarantee the persistence of data. All the information sent to the Kafka server is saved into a NoSQL database by Prometheus.
            
            Grafana is an interactive open-source data visualization platform developed by Grafana Labs. It allows users to view data through unified tables and charts on a single or multiple dashboards, making interpretation and understanding easier. In our work, Grafana and Prometheus work in tandem. Once the data is saved persistently by Prometheus, it's then retrieved by Grafana to build and show a comprehensive dashboard of each topic to the user.</p>
        
        
        
        
        </div>
    </div>

</body>

</html>
