<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RecurrentModel Method</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .method {
            background-color: #f8f8f8;
        }
    </style>
</head>
<body>
    <h1>Smartville</h1>
    <table>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
class MulticlassPrototypicalClassifier(nn.Module):

    def __init__(self, device='cpu'):
        """
        Initializes a MulticlassPrototypicalClassifier instance.

        Args:
        - device (str): The device to run the model on. Default is 'cpu'.
        """
        super(MulticlassPrototypicalClassifier, self).__init__()
        self.device = device
                </code></pre>
            </td>
            <td>
                <p>
                    Il metodo `__init__` è il costruttore della classe e inizializza un'istanza del classificatore prototipico multiclasse. Accetta un parametro `device` che specifica il dispositivo su cui eseguire il modello (il valore predefinito è 'cpu').
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    def get_oh_labels(
        self,
        decimal_labels,
        n_way):
        """
        Generates one-hot encoded labels.

        Args:
        - decimal_labels (torch.Tensor): Decimal labels.
        - n_way (int): Number of classes.

        Returns:
        - torch.Tensor: One-hot encoded labels.
        """
        # create placeholder for one_hot encoding:
        labels_onehot = torch.zeros(
            [decimal_labels.size()[0],
            n_way], device=self.device)
        # transform to one_hot encoding:
        labels_onehot = labels_onehot.scatter(
            1,
            decimal_labels,
            1)
        return labels_onehot
                </code></pre>
            </td>
            <td>
                <p>
                    Il metodo `get_oh_labels` genera etichette codificate one-hot a partire da etichette decimali. Prende come argomenti le etichette decimali e il numero di classi (`n_way`). Restituisce le etichette codificate one-hot.
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    def get_centroids(
            self,
            hidden_vectors,
            onehot_labels):
        """
        Computes centroids of clusters.

        Args:
        - hidden_vectors (torch.Tensor): Hidden vectors.
        - onehot_labels (torch.Tensor): One-hot encoded labels.

        Returns:
        - torch.Tensor: Centroids of clusters.
        - torch.Tensor: Missing clusters.
        """

        cluster_agg = onehot_labels.T @ hidden_vectors
        samples_per_cluster = onehot_labels.sum(0)
        centroids = torch.zeros_like(cluster_agg, device=self.device)
        missing_clusters = samples_per_cluster == 0
        existent_centroids = cluster_agg[~missing_clusters] / \
            samples_per_cluster[~missing_clusters].unsqueeze(-1)
        centroids[~missing_clusters] = existent_centroids
        assert torch.all(centroids[~missing_clusters] == existent_centroids)
        return centroids, missing_clusters
                </code></pre>
            </td>
            <td>
                <p>
                    Il metodo `get_centroids` calcola i centroidi dei cluster basandosi sui vettori nascosti e sulle etichette codificate one-hot. Prende come argomenti i vettori nascosti e le etichette codificate one-hot. Restituisce i centroidi dei cluster e un indicatore per i cluster mancanti.
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    def forward(self, hidden_vectors, labels, known_attacks_count, query_mask):
        """
        Defines the forward pass of the model.

        Args:
        - hidden_vectors (torch.Tensor): Hidden vectors.
        - labels (torch.Tensor): Labels.
        - known_attacks_count (int): Current number of known attacks.
        - query_mask (torch.Tensor): Mask for queries.

        Returns:
        - torch.Tensor: Scores.
        """
        # get one_hot_labels of current batch:
        oh_labels = self.get_oh_labels(
            decimal_labels=labels.long(),
            n_way=known_attacks_count)

        # get latent centroids:
        centroids, _ = self.get_centroids(
            hidden_vectors[~query_mask],
            oh_labels[~query_mask])

        # compute scores:
        scores = 1 / (torch.cdist(hidden_vectors[query_mask], centroids) + 1e-10)

        return scores
                </code></pre>
            </td>
            <td>
                <p>
                    Il metodo `forward` definisce il passaggio in avanti del modello, che calcola i punteggi per ogni campione di input in base ai suoi vettori nascosti, etichette, numero di attacchi conosciuti e maschera di query. Prende come argomenti i vettori nascosti, le etichette, il numero di attacchi conosciuti e la maschera di query. Restituisce i punteggi calcolati.
                </p>
            </td>
        </tr>
    </table>
</body>
</html>
