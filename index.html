<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RecurrentModel Method</title>
    <style>
        body {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 20px;
            background-color: #1E1E1E;
            color: #D4D4D4;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            border: 1px solid #2D2D2D;
            text-align: left;
        }
        th {
            background-color: #252526;
            color: #D4D4D4;
        }
        .method {
            background-color: #252526;
            color: #D4D4D4;
        }
        pre {
            background-color: #1E1E1E;
            color: #D4D4D4;
            padding: 10px;
            overflow-x: auto;
            margin-bottom: 0;
        }
        code {
            color: #D4D4D4;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .keyword {
            color: #569CD6;
        }
        .comment {
            color: #6A9955;
        }
        .string {
            color: #CE9178;
        }
    </style>
</head>
<body>
    <h1>Smartville</h1>
    <table>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
<span class="keyword">class</span> MulticlassPrototypicalClassifier(nn.Module):

    <span class="keyword">def</span> __init__(self, device='cpu'):
        """
        Initializes a MulticlassPrototypicalClassifier instance.

        Args:
        - device (str): The device to run the model on. Default is 'cpu'.
        """
        super(MulticlassPrototypicalClassifier, self).__init__()
        self.device = device
                </code></pre>
            </td>
            <td>
                <p>
                    The <code>__init__</code> method is the constructor of the class and initializes an instance of the multiclass prototypical classifier. It accepts a <code>device</code> parameter that specifies the device to run the model on (default is 'cpu').
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    <span class="keyword">def</span> get_oh_labels(
        self,
        decimal_labels,
        n_way):
        """
        Generates one-hot encoded labels.

        Args:
        - decimal_labels (torch.Tensor): Decimal labels.
        - n_way (int): Number of classes.

        Returns:
        - torch.Tensor: One-hot encoded labels.
        """
        # create placeholder for one_hot encoding:
        labels_onehot = torch.zeros(
            [decimal_labels.size()[0],
            n_way], device=self.device)
        # transform to one_hot encoding:
        labels_onehot = labels_onehot.scatter(
            1,
            decimal_labels,
            1)
        return labels_onehot
                </code></pre>
            </td>
            <td>
                <p>
                    The <code>get_oh_labels</code> method generates one-hot encoded labels from decimal labels. It takes decimal labels and the number of classes (<code>n_way</code>) as arguments. It returns the one-hot encoded labels.
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    <span class="keyword">def</span> get_centroids(
            self,
            hidden_vectors,
            onehot_labels):
        """
        Computes centroids of clusters.

        Args:
        - hidden_vectors (torch.Tensor): Hidden vectors.
        - onehot_labels (torch.Tensor): One-hot encoded labels.

        Returns:
        - torch.Tensor: Centroids of clusters.
        - torch.Tensor: Missing clusters.
        """

        cluster_agg = onehot_labels.T @ hidden_vectors
        samples_per_cluster = onehot_labels.sum(0)
        centroids = torch.zeros_like(cluster_agg, device=self.device)
        missing_clusters = samples_per_cluster == 0
        existent_centroids = cluster_agg[~missing_clusters] / \
            samples_per_cluster[~missing_clusters].unsqueeze(-1)
        centroids[~missing_clusters] = existent_centroids
        assert torch.all(centroids[~missing_clusters] == existent_centroids)
        return centroids, missing_clusters
                </code></pre>
            </td>
            <td>
                <p>
                    The <code>get_centroids</code> method computes centroids of clusters based on hidden vectors and one-hot encoded labels. It takes hidden vectors and one-hot encoded labels as arguments. It returns the centroids of clusters and an indicator for missing clusters.
                </p>
            </td>
        </tr>
        <tr>
            <td class="method">
                <pre><code>
    <span class="keyword">def</span> forward(self, hidden_vectors, labels, known_attacks_count, query_mask):
        """
        Defines the forward pass of the model.

        Args:
        - hidden_vectors (torch.Tensor): Hidden vectors.
        - labels (torch.Tensor): Labels.
        - known_attacks_count (int): Current number of known attacks.
        - query_mask (torch.Tensor): Mask for queries.

        Returns:
        - torch.Tensor: Scores.
        """
        # get one_hot_labels of current batch:
        oh_labels = self.get_oh_labels(
            decimal_labels=labels.long(),
            n_way=known_attacks_count)

        # get latent centroids:
        centroids, _ = self.get_centroids(
            hidden_vectors[~query_mask],
            oh_labels[~query_mask])

        # compute scores:
        scores = 1 / (torch.cdist(hidden_vectors[query_mask], centroids) + 1e-10)

        return scores
                </code></pre>
            </td>
            <td>
                <p>
                    The <code>forward</code> method defines the forward pass of the model, which computes scores for each input sample based on its hidden vectors, labels, number of known attacks, and query mask. It takes hidden vectors, labels, the number of known attacks, and the query mask as arguments. It returns the computed scores.
                </p>
            </td>
        </tr>
    </table>
</body>
</html>
